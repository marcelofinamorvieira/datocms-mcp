import { buildClient } from '@datocms/cma-client-node';
import fs from 'fs';

/*

Content Management API > Field
Field
DatoCMS offers a number of different fields that you can combine together to create a Model. Using the database metaphore, fields are like table columns, and when creating them you need to specify their type (string, float, etc.) and any required validation.

Different field types require different settings
When looking at a field resource, you have to pay attention to two particular properties, validators and appearance.

The validators property expresses the set of validations to be performed server-side on a specific field value for it to be considered valid, while the appearance property lets you specify how the field itself will be presented inside the form to the final editor.

For both properties, the value to specify depends on the type of field itself. For example, you can add a "Limit character count" validation to a Single-line string field, or set its appearence to "Show it as heading", but they won't be accepted for a ie. Color field, as it supports different validations and appearance settings.

Specifying validations
The validators property requires an object whose keys are the validations that you want to be enforced, and the values are objects representing any settings that the validation itself requires. If the validation doesn't have additional settings, you just pass down an empty object.

This is a valid example for a Single-line string field:

{
  "validators": {
    // "required" validator has no settings
    "required": {},
    // "length" validator requires "min" and/or "max" properties
    "length": { "min": 80 }
  }
}

Below you'll find a summary of all the validators available for each field type with their settings.

Some validators are required for a specific type of field. For example, the Modular Content field needs to have a rich_text_blocks validator, specifying which types of blocks it can contain.

Specifying the appearance
The appearance property requires an object with three specific properties: editor, parameters and addons.

The editor represents the type of editor that the users will see inside the form to change the value of this specific field. Depending on the type of field, DatoCMS offers a number of different editors for you to choose from. The parameters property is an object representing any additional settings that the editor itself might require.

This is a valid example for a Single-line string field:

{
  "appearance": {
    // single_line is a DatoCMS built-in editor that you can use with single-line string fields
    "editor": "single_line",
    // each built-in editor has specific settings
    "parameters": { "heading": true, "placeholder": "My blog post title" },
    "addons": []
  },
}

Following you'll find a summary of all the editors available for each field type with their settings.

Setting the appearance to a field editor provided by a plugin
If the project contains a plugin that exposes manual field editors, you can also configure the field to be presented with it instead of using one of the built-in editors.

In this case:

the editor property is the plugin's project-specific autogenerated UUID. You can get it from the last part of the plugin's URL within your project's Configuration screen (e.g. https://your-project.admin.datocms.com/configuration/plugins/PLUGIN_UUID/), or via API with a List all plugins call.
the field_extension property must be the ID of the specific manual field editor that the plugin exposes. This is set in the plugin's own source code, within a manualFieldExtension() call in its entry point (usually something like index.tsx).
the parameters property must provide a configuration object compatible with the config screen of the manual field extension, or an empty object if it doesn't require any configuration.
{
  "appearance": {
    // "2132" is a the ID of a plugin exposing a manual field editor
    "editor": "2134",
    // "starRating" is a manual field editor exposed by the plugin
    "field_extension": "starRating",
    // this is a valid configuration for the "starRating" field editor
    "parameters": { "maxRating": 5, "starsColor": "#ff0000" },
    "addons": []
  },
}

Configuring manual field addons
If the project contains plugins that expose manual field addons, you can also add them to the field via the addons property.

{
  "appearance": {
    "editor": "single_line",
    "parameters": { "heading": true, "placeholder": "My blog post title" },
    "addons": [
      {
        // "2138" is a the ID of a plugin exposing a manual addon editor
        "id": "2138",
        // "loremIpsumGenerator" is a manual field addon exposed by the plugin
        "field_extension": "loremIpsumGenerator",
        // this is a valid configuration for the "loremIpsumGenerator" field addon
        "parameters": { "sentences": 2 },
      }
    ]
  },
}

Available field types
Single-line string (string)
Property	Value
Code	string
Built-in editors for the field	single_line, string_radio_group, string_select
Available validators	required, unique, length, format, enum
Multi-line text (text)
Property	Value
Code	text
Built-in editors for the field	markdown, wysiwyg, textarea
Available validators	required, length, format, sanitization
Boolean (boolean)
Property	Value
Code	boolean
Built-in editors for the field	boolean, boolean_radio_group
Available validators	no validators available
Integer (integer)
Property	Value
Code	integer
Built-in editors for the field	integer
Available validators	required, number_range
Float (float)
Property	Value
Code	float
Built-in editors for the field	float
Available validators	required, number_range
Date (date)
Property	Value
Code	date
Built-in editors for the field	date_picker
Available validators	required, date_range
Date time (date_time)
Property	Value
Code	date_time
Built-in editors for the field	date_time_picker
Available validators	required, date_time_range
Color (color)
Property	Value
Code	color
Built-in editors for the field	color_picker
Available validators	required
JSON (json)
Property	Value
Code	json
Built-in editors for the field	json, string_multi_select, string_checkbox_group
Available validators	required
Location (lat_lon)
Property	Value
Code	lat_lon
Built-in editors for the field	map
Available validators	required
SEO and Social (seo)
Property	Value
Code	seo
Built-in editors for the field	seo
Available validators	required_seo_fields, file_size, image_dimensions, image_aspect_ratio, title_length, description_length
Slug (slug)
Property	Value
Code	slug
Built-in editors for the field	slug
Available validators	required, length, slug_format, slug_title_field
External video (video)
Property	Value
Code	video
Built-in editors for the field	video
Available validators	required
Single-asset (file)
Property	Value
Code	file
Built-in editors for the field	file
Available validators	required, file_size, image_dimensions, image_aspect_ratio, extension, required_alt_title
Asset gallery (gallery)
Property	Value
Code	gallery
Built-in editors for the field	gallery
Available validators	size, file_size, image_dimensions, image_aspect_ratio, extension, required_alt_title
Single link (link)
Property	Value
Code	link
Built-in editors for the field	link_select, link_embed
Default editor	link_select
Required validators	item_item_type
Other validators available	required, unique
Multiple links (links)
Property	Value
Code	links
Built-in editors for the field	links_select, links_embed
Default editor	links_select
Required validators	items_item_type
Other validators available	size
Modular content (rich_text)
Property	Value
Code	rich_text
Built-in editors for the field	rich_text
Required validators	rich_text_blocks
Other validators available	size
Single Block (single_block)
Property	Value
Code	single_block
Built-in editors for the field	framed_single_block, frameless_single_block
Required validators	single_block_blocks
Other validators available	required
Structured text (structured_text)
Property	Value
Code	structured_text
Built-in editors for the field	structured_text
Required validators	structured_text_blocks, structured_text_links
Other validators available	length, structured_text_inline_blocks
Validators
date_range
Accept dates only inside a specified date range.

Parameter	Type	Required	Description
min	ISO 8601 date		Minimum date
max	ISO 8601 date		Maximum date
At least one of the parameters must be specified.

date_time_range
Accept date times only inside a specified date range.

Parameter	Type	Required	Description
min	ISO 8601 datetime		Minimum datetime
max	ISO 8601 datetime		Maximum datetime
At least one of the parameters must be specified.

enum
Only accept a specific set of values

Parameter	Type	Required	Description
values	Array<String>	✅	Set of allowed values
extension
Only accept assets with specific file extensions.

Parameter	Type	Required	Description
extensions	Array<String>		Set of allowed file extensions
predefined_list	one of "image", "transformable_image", "video", "document"		Allowed file type
Only one of the parameters must be specified.

file_size
Accept assets only inside a specified date range.

Parameter	Type	Required	Description
min_value	Integer		Numeric value for minimum filesize
min_unit	one of "B", "KB", "MB"		Unit for minimum filesize
max_value	Integer		Numeric value for maximum filesize
max_unit	one of "B", "KB", "MB"		Unit for maximum filesize
At least one couple of value/unit must be specified.

format
Accepts only strings that match a specified format.

Parameter	Type	Required	Description
custom_pattern	Regexp	Optional	Custom regular expression for validation
predefined_pattern	"email" or "url"	Optional	Specifies a pre-defined format (email or URL)
Note: Only one of custom_pattern or predefined_pattern should be specified.

If custom_pattern is used, an additional description parameter can be provided to serve as a hint for the user. This hint offers a simple explanation of the expected pattern, such as "The field must end with an 's'", instead of the default message like "Field must match the pattern: /s$/".

slug_format
Only accept slugs having a specific format.

Parameter	Type	Required	Description
custom_pattern	Regexp		Regular expression to be validated
predefined_pattern	"webpage_slug"		Allowed format
Only one of the parameters must be specified.

image_dimensions
Accept assets only within a specified height and width range.

Parameter	Type	Required	Description
width_min_value	Integer		Numeric value for minimum width
width_max_value	Integer		Numeric value for maximum height
height_min_value	Integer		Numeric value for minimum width
height_max_value	Integer		Numeric value for maximum height
At least one pair of height/width parameters must be specified.

image_aspect_ratio
Accept assets only within a specified aspect ratio range.

Parameter	Type	Required	Description
min_ar_numerator	Integer		Numerator part of the minimum aspect ratio
min_ar_denominator	Integer		Denominator part of the minimum aspect ratio
eq_ar_numerator	Integer		Numerator part for the required aspect ratio
eq_ar_denominator	Integer		Denominator part for the required aspect ratio
max_ar_numerator	Integer		Numerator part of the maximum aspect ratio
max_ar_denominator	Integer		Denominator part of the maximum aspect ratio
At least one pair of numerator/denominator must be specified.

item_item_type
Only accept references to records of the specified models.

Parameter	Type	Required	Description
item_types	Array<Model ID>	✅	Set of allowed model IDs
on_publish_with_unpublished_references_strategy	"fail", "publish_references" (default value: "fail")		Strategy to apply when a publishing is requested and this field references some unpublished records
on_reference_unpublish_strategy	"fail", "unpublish", "delete_references" (default value: "fail")		Strategy to apply when unpublishing is requested for a record referenced by this field
on_reference_delete_strategy	"fail", "delete_references" (default value: "delete_references")		Strategy to apply when deletion is requested for a record referenced by this field
Possible values for on_publish_with_unpublished_references_strategy:

"fail": Fail the operation and notify the user
"publish_references": Publish also the referenced records
Possible values for on_reference_unpublish_strategy:

"fail": Fail the operation and notify the user
"unpublish": Unpublish also this record
"delete_references": Try to remove the reference to the unpublished record (if the field has a required validation it will fail)
Possible values for on_reference_delete_strategy:

"fail": Fail the operation and notify the user
"delete_references": Try to remove the reference to the deleted record (if the field has a required validation it will fail)
items_item_type
Only accept references to records of the specified models.

Parameter	Type	Required	Description
item_types	Array<Model ID>	✅	Set of allowed model IDs
on_publish_with_unpublished_references_strategy	"fail", "publish_references" (default value: "fail")		Strategy to apply when a publishing is requested and this field references some unpublished records
on_reference_unpublish_strategy	"fail", "unpublish", "delete_references" (default value: "fail")		Strategy to apply when unpublishing is requested for a record referenced by this field
on_reference_delete_strategy	"fail", "delete_references" (default value: "delete_references")		Strategy to apply when deletion is requested for a record referenced by this field
Possible values for on_publish_with_unpublished_references_strategy:

"fail": Fail the operation and notify the user
"publish_references": Publish also the referenced records
Possible values for on_reference_unpublish_strategy:

"fail": Fail the operation and notify the user
"unpublish": Unpublish also this record
"delete_references": Try to remove the reference to the unpublished record (if the field has a required validation it will fail)
Possible values for on_reference_delete_strategy:

"fail": Fail the operation and notify the user
"delete_references": Try to remove the reference to the deleted record (if the field has a required validation it will fail)
length
Accept strings only with a specified number of characters.

Parameter	Type	Required	Description
min	Integer		Minimum length
eq	Integer		Expected length
max	Integer		Maximum length
At least one parameter must be specified.

number_range
Accept numbers only inside a specified range.

Parameter	Type	Required	Description
min	Float		Minimum value
max	Float		Maximum value
At least one of the parameters must be specified.

required
Value must be specified or it won't be valid.

required_alt_title
Assets contained in the field are required to specify custom title or alternate text, or they won't be valid.

Parameter	Type	Required	Description
title	Boolean		Whether the title for the asset must be specified
alt	Boolean		Whether the alternate text for the asset must be specified
At least one of the parameters must be specified.

required_seo_fields
SEO field has to specify one or more properties, or it won't be valid.

Parameter	Type	Required	Description
title	Boolean		Whether the meta title must be specified
description	Boolean		Whether the meta description must be specified
image	Boolean		Whether the social sharing image must be specified
twitter_card	Boolean		Whether the type of Twitter card must be specified
At least one of the parameters must be specified.

title_length
Limits the length of the title for a SEO field. Search engines usually truncate title tags to 60 character so it is a good practice to keep the title around this length.

Parameter	Type	Required	Description
min	Integer		Minimum value
max	Integer		Maximum value
At least one of the parameters must be specified.

description_length
Limits the length of the description for a SEO field. Search engines usually truncate description tags to 160 character so it is a good practice to keep the description around this length.

Parameter	Type	Required	Description
min	Integer		Minimum value
max	Integer		Maximum value
At least one of the parameters must be specified.

rich_text_blocks
Only accept references to block records of the specified block models.

Parameter	Type	Required	Description
item_types	Array<Block Model ID>	✅	Set of allowed Block Model IDs
single_block_blocks
Only accept references to block records of the specified block models.

Parameter	Type	Required	Description
item_types	Array<Block Model ID>	✅	Set of allowed Block Model IDs
sanitization
Checks for the presence of malicious cose in HTML fields: content is valid if no dangerous code is present.

Parameter	Type	Required	Description
sanitize_before_validation	Boolean	✅	Content is actively sanitized before applying the validation
structured_text_blocks
Only accept references to block records of the specified block models.

Parameter	Type	Required	Description
item_types	Array<Block Model ID>	✅	Set of allowed Block Model IDs
structured_text_inline_blocks
Only accept references to block records of the specified block models.

Parameter	Type	Required	Description
item_types	Array<Block Model ID>	✅	Set of allowed Block Model IDs
structured_text_links
Only accept itemLink to inlineItem nodes for records of the specified models.

Parameter	Type	Required	Description
item_types	Array<Model ID>	✅	Set of allowed model IDs
on_publish_with_unpublished_references_strategy	"fail", "publish_references" (default value: "fail")		Strategy to apply when a publishing is requested and this field references some unpublished records
on_reference_unpublish_strategy	"fail", "unpublish", "delete_references" (default value: "delete_references")		Strategy to apply when unpublishing is requested for a record referenced by this field
on_reference_delete_strategy	"fail", "delete_references" (default value: "delete_references")		Strategy to apply when deletion is requested for a record referenced by this field
Possible values for on_publish_with_unpublished_references_strategy:

"fail": Fail the operation and notify the user
"publish_references": Publish also the referenced records
Possible values for on_reference_unpublish_strategy:

"fail": Fail the operation and notify the user
"unpublish": Unpublish also this record
"delete_references": Try to remove the reference to the unpublished record (if the field has a required validation it will fail)
Possible values for on_reference_delete_strategy:

"fail": Fail the operation and notify the user
"delete_references": Try to remove the reference to the deleted record (if the field has a required validation it will fail)
size
Only accept a number of items within the specified range.

Parameter	Type	Required	Description
min	Integer		Minimum length
eq	Integer		Expected length
max	Integer		Maximum length
multiple_of	Integer		The number of items must be multiple of this value
At least one parameter must be specified.

slug_title_field
Specifies the ID of the Single-line string field that will be used to generate the slug

Parameter	Type	Required	Description
title_field_id	Field ID	✅	The field that will be used to generate the slug
unique
The value must be unique across the whole collection of records.

Configuration parameters for DatoCMS built-in field editors
If a field editor is not specified in this table, just pass an empty object {} as its configuration parameters.

boolean_radio_group
Radio group input for boolean fields.

Parameter	Type	Required	Description
positive_radio	{ label: string, hint?: string }	✅	Radio input for positive choice (true)
negative_radio	{ label: string, hint?: string }	✅	Radio input for negative choice (false)
string_radio_group
Radio group input for string fields.

Parameter	Type	Required	Description
radios	Array<{ label: string, value: string, hint?: string }>	✅	The different radio options
string_select
Select input for string fields.

Parameter	Type	Required	Description
options	Array<{ label: string, value: string, hint?: string }>	✅	The different select options
string_multi_select
Select input for JSON fields, to edit an array of strings.

Parameter	Type	Required	Description
options	Array<{ label: string, value: string, hint?: string }>	✅	The different select options
string_checkbox_group
Multiple chechboxes input for JSON fields, to edit an array of strings.

Parameter	Type	Required	Description
options	Array<{ label: string, value: string, hint?: string }>	✅	The different select options
single_line
Simple textual input for Single-line string fields.

Parameter	Type	Required	Description
heading	Boolean	✅	Indicates if the field should be shown bigger, as a field representing a heading
placeholder	String		A placeholder that will be shown in the editor's input to provide editors with an example.
markdown
Markdown editor for Multiple-paragraph text fields.

Parameter	Type	Required	Description
toolbar	Array<String>	✅	Specify which buttons the toolbar should have. Valid values: "heading", "bold", "italic", "strikethrough", "code", "unordered_list", "ordered_list", "quote", "link", "image", "fullscreen"
wysiwyg
HTML editor for Multiple-paragraph text fields.

Parameter	Type	Required	Description
toolbar	Array<String>	✅	Specify which buttons the toolbar should have. Valid values: "format", "bold", "italic", "strikethrough", "code", "ordered_list", "unordered_list", "quote", "table", "link", "image", "show_source", "undo", "redo", "align_left", "align_center", "align_right", "align_justify", "outdent", "indent", "fullscreen"
textarea
Basic textarea editor for Multiple-paragraph text fields.

Parameter	Type	Required	Description
placeholder	String		A placeholder that will be shown in the editor's input to provide editors with an example.
color_picker
Built-in editor for Color fields.

Parameter	Type	Required	Description
enable_alpha	Boolean	✅	Should the color picker allow to specify the alpha value?
preset_colors	Array<Hex color string>	✅	List of preset colors to offer to the user
slug
Built-in editor for Slug fields.

Parameter	Type	Required	Description
url_prefix	String		A prefix that will be shown in the editor's form to give some context to your editors.
placeholder	String		A placeholder that will be shown in the editor's input to provide editors with an example.
seo
Built-in editor for seo fields.

Parameter	Type	Required	Description
fields	Array<String>	✅	Specify which fields of the SEO input should be visible to editors. Valid values: "title", "description", "image", "no_index", "twitter_card"
previews	Array<String>	✅	Specify which previews should be visible to editors. Valid values: "google_search", "twitter", "slack", "whatsapp", "telegram", "facebook", "linkedin"
rich_text
Built-in editor for Modular content fields.

framed_single_block
Built-in editor for Single block fields. No additional parameters are required.
structured_text
Built-in editor for Structured text fields.

Parameter	Type	Required	Description
nodes	Array<String>	✅	Specify which nodes the field should allow. Valid values: "blockquote", "code", "heading", "link", "list", "thematicBreak"
marks	Array<String>	✅	Specify which marks the field should allow. Valid values: "strong", "emphasis", "underline", "strikethrough", "code", "highlight"
heading_levels	Array<Integer>	✅	If nodes includes "heading", specify which heading levels the field should allow. Valid values: numbers between 1 and 6
blocks_start_collapsed	Boolean		Whether you want block nodes collapsed by default or not
show_links_target_blank	Boolean		Whether you want to show the "Open this link in a new tab?" checkbox, that fills in the target: "_blank" meta attribute for links
show_links_meta_editor	Boolean		Whether you want to show the complete meta editor for links
link_select and links_select
Use a select input with auto-completion to pick the records to reference inside the field.

link_embed and links_embed
Use an expanded view with records' image preview to pick the records to reference inside the field.

integer
Built-in editor for Integer fields.

Parameter	Type	Required	Description
placeholder	String		A placeholder that will be shown in the editor's input to provide editors with an example.
float
Built-in editor for Float fields.

Parameter	Type	Required	Description
placeholder	String		A placeholder that will be shown in the editor's input to provide editors with an example.
Object payload 
id
string
RFC 4122 UUID of field expressed in URL-safe base64 format

Example: "Pkg-oztERp6o-Rj76nYKJg"
type
string
Must be exactly "field".

label
string
The label of the field

Example: "Title"
field_type
enum
Type of input

Example: "string"

Show enum values
boolean
color
date
date_time
file
float
gallery
integer
json
lat_lon
link
links
rich_text
seo
single_block
slug
string
structured_text
text
video
api_key
string
Field API key

Example: "title"
localized
boolean
Whether the field needs to be multilanguage or not

validators
object
Optional field validations

Example: { required: {} }
position
integer
Ordering index

Example: 1
hint
string, null
Field hint

Example: "This field will be used as post title"
default_value
Default value for Field. When field is localized accepts an object of default values with site locales as keys

Type: boolean, null, string, number, object
Example: { en: "A default value", it: "Un valore di default" }
appearance
object
Field appearance details, plugin configuration and field add-ons

Example: { editor: "single_line", parameters: { heading: false }, addons: [{ id: "1234", field_extension: "lorem_ipsum", parameters: {} }], }

Show object format
editor
string
A valid editor can be a DatoCMS default field editor type (ie. "single_line"), or a plugin ID offering a custom field editor

parameters
object
The editor plugin's parameters

addons
An array of add-on plugins with id and parameters

Type: Array<object>

Show objects format inside array
id
string
The ID of a plugin offering a field addon

parameters
object
field_extension
string
The specific field extension to use for the field (only if the editor is a modern plugin)

field_extension
string
The specific field extension to use for the field (only if the editor is a modern plugin)

deep_filtering_enabled
boolean
Whether deep filtering for block models is enabled in GraphQL or not

item_type
Field item type

Type: ResourceLinkage<"item_type">
fieldset
Fieldset linkage

Type: null, ResourceLinkage<"fieldset">


*/

/*

Content Management API > Field
Create a new field
Body parameters 
id
string
Optional
RFC 4122 UUID of field expressed in URL-safe base64 format

Example: "Pkg-oztERp6o-Rj76nYKJg"
label
string
Required
The label of the field

Example: "Title"
field_type
enum
Required
Type of input

Example: "string"

Show enum values
boolean
Optional
color
Optional
date
Optional
date_time
Optional
file
Optional
float
Optional
gallery
Optional
integer
Optional
json
Optional
lat_lon
Optional
link
Optional
links
Optional
rich_text
Optional
seo
Optional
single_block
Optional
slug
Optional
string
Optional
structured_text
Optional
text
Optional
video
Optional
api_key
string
Required
Field API key

Example: "title"
localized
boolean
Optional
Whether the field needs to be multilanguage or not

validators
object
Optional
Optional field validations

Example: { required: {} }
appearance
object
Optional
Field appearance details, plugin configuration and field add-ons

Example: { editor: "single_line", parameters: { heading: false }, addons: [{ id: "1234", field_extension: "lorem_ipsum", parameters: {} }], }

Show object format
editor
string
Required
A valid editor can be a DatoCMS default field editor type (ie. "single_line"), or a plugin ID offering a custom field editor

parameters
object
Required
The editor plugin's parameters

addons
Required
An array of add-on plugins with id and parameters

Type: Array<object>

Show objects format inside array
id
string
Required
The ID of a plugin offering a field addon

parameters
object
Required
field_extension
string
Optional
The specific field extension to use for the field (only if the editor is a modern plugin)

field_extension
string
Optional
The specific field extension to use for the field (only if the editor is a modern plugin)

position
integer
Optional
Ordering index

Example: 1
hint
string, null
Optional
Field hint

Example: "This field will be used as post title"
default_value
Optional
Default value for Field. When field is localized accepts an object of default values with site locales as keys

Type: boolean, null, string, number, object
Example: { en: "A default value", it: "Un valore di default" }
deep_filtering_enabled
boolean
Optional
Whether deep filtering for block models is enabled in GraphQL or not

fieldset
Optional
Fieldset linkage

Type: null, ResourceLinkage<"fieldset">

Show deprecated
Returns 
Returns a resource object of type field

Other examples
Example Basic example 
This is a complete example for creating a new localized Single-line string field:

CodeReturned output
import { buildClient } from "@datocms/cma-client-node";

async function run() {
  const client = buildClient({ apiToken: process.env.DATOCMS_API_TOKEN });

  const modelIdOrApiKey = "blog_post";

  const field = await client.fields.create(modelIdOrApiKey, {
    label: "Title",
    field_type: "string",
    api_key: "title",
  });

  // Check the 'Returned output' tab for the result ☝️
}

run();

Example Creating Modular Content fields 
In this example:

first we create some block models using the client.itemTypes.create() method, making sure to set the modular_block attribute to true — this tells the API that they're in fact block models, and not regular models;
we then create a Modular content field, passing down the allowed block models in the rich_text_blocks validator:
CodeReturned output
import { buildClient } from "@datocms/cma-client-node";

async function run() {
  // Make sure the API token has access to the CMA, and is stored securely
  const client = buildClient({ apiToken: process.env.DATOCMS_API_TOKEN });

  const modularBlock1 = await client.itemTypes.create({
    name: "Modular Block 1",
    api_key: "modular_block1",
    modular_block: true,
  });

  const modularBlock2 = await client.itemTypes.create({
    name: "Modular Block 2",
    api_key: "modular_block2",
    modular_block: true,
  });

  const itemTypeId = "1234";

  const field = await client.fields.create(itemTypeId, {
    label: "Content",
    field_type: "rich_text",
    api_key: "content",
    validators: {
      rich_text_blocks: {
        item_types: [modularBlock1.id, modularBlock2.id],
      },
    },
  });

}

run();

Example Creating Structured Text fields 
Structured Text fields support both embedded block records and links to other regular records.

For DatoCMS, a block model is just like a regular model, so we'll create them with client.itemTypes.create(), passing the modularBlock property to true:

In this example:

first we create some block models using the client.itemTypes.create() method, making sure to set the modular_block attribute to true — this tells the API that they're in fact block models, and not regular models;
we then create the Structured Text field, passing down the embeddable block models in the structured_text_blocks and structured_text_inline_blocks validator, and the linkable record models in the structured_text_links validator:
CodeReturned output
import { buildClient } from "@datocms/cma-client-node";

async function run() {
  // Make sure the API token has access to the CMA, and is stored securely
  const client = buildClient({ apiToken: process.env.DATOCMS_API_TOKEN });

  const modularBlock1 = await client.itemTypes.create({
    name: "Modular Block 1",
    api_key: "modular_block1",
    modular_block: true,
  });

  const modularBlock2 = await client.itemTypes.create({
    name: "Modular Block 2",
    api_key: "modular_block2",
    modular_block: true,
  });

  const itemTypeId = "1234";

  const field = await client.fields.create(itemTypeId, {
    label: "Structured content",
    field_type: "structured_text",
    api_key: "content",
    validators: {
      structured_text_blocks: {
        item_types: [modularBlock1.id, modularBlock2.id],
      },
      structured_text_inline_blocks: {
        item_types: [modularBlock1.id],
      },
      structured_text_links: {
        item_types: [itemTypeId],
      },
    },
  });

}

run();

*/

// Initialize the DatoCMS client
const client = buildClient({
  apiToken: "f9a6a96f1825925f275ccee763db90",
});

// Generate a random suffix to ensure unique model name and API key
const randomSuffix = Math.floor(Math.random() * 100000);

// Results tracking
const results = {
  successful: [],
  failed: []
};

/**
 * Helper function to create a field with error handling
 */
async function createField(model, fieldConfig) {
  try {
    
    // Ensure all appearance objects have addons and parameters
    if (fieldConfig.appearance) {
      fieldConfig.appearance.addons = fieldConfig.appearance.addons || [];
      fieldConfig.appearance.parameters = fieldConfig.appearance.parameters || {};
    }
    
    const field = await client.fields.create(model.id, fieldConfig);
    
    // Track success
    results.successful.push({
      field_type: field.field_type,
      editor: field.appearance?.editor || 'default',
      label: field.label
    });
    
    return field;
  } catch (error) {
    
    // Track failure
    results.failed.push({
      field_type: fieldConfig.field_type,
      editor: fieldConfig.appearance?.editor || 'default',
      label: fieldConfig.label,
      error: error.message
    });
    
    // Continue with other fields instead of stopping execution
    return null;
  }
}

/**
 * Main function to create a model with all field types
 * with appropriate validators and configurations
 */
async function createComprehensiveModel() {
  try {
    
    // Create a new model
    const model = await client.itemTypes.create({
      name: `Comprehensive Model ${randomSuffix}`,
      api_key: `comprehensive_model${randomSuffix}`,
      singleton: false
    });
    
    
    // Create a reference model for link/links fields
    const refModel = await client.itemTypes.create({
      name: `Reference Model ${randomSuffix}`,
      api_key: `reference_model${randomSuffix}`,
      singleton: false
    });
    
    // Add a title field to the reference model
    await createField(refModel, {
      label: "Reference Title",
      api_key: "reference_title",
      field_type: "string"
    });
    
    // Create modular block models for structured text and rich text
    const textBlockModel = await client.itemTypes.create({
      name: `Text Block ${randomSuffix}`,
      api_key: `text_block${randomSuffix}`,
      modular_block: true
    });
    
    // Add text field to the block model
    await createField(textBlockModel, {
      label: "Block Content",
      api_key: "block_content",
      field_type: "text"
    });
    
    const imageBlockModel = await client.itemTypes.create({
      name: `Image Block ${randomSuffix}`,
      api_key: `image_block${randomSuffix}`,
      modular_block: true
    });
    
    // Add image field to the image block model
    await createField(imageBlockModel, {
      label: "Block Image",
      api_key: "block_image",
      field_type: "file"
    });

    // Now create all possible field types on the main model
    
    // 1. String field with single_line editor
    await createField(model, {
      label: "Title",
      api_key: "title",
      field_type: "string"
    });
    
    // 2. String field with string_radio_group editor
    await createField(model, {
      label: "Content Type",
      api_key: "content_type",
      field_type: "string",
      appearance: {
        editor: "string_radio_group",
        parameters: {
          radios: [
            { label: "Article", value: "article" },
            { label: "Tutorial", value: "tutorial" }
          ]
        },
        addons: []
      },
      validators: {
        enum: {
          values: ["article", "tutorial"]
        }
      }
    });
    
    // 3. String field with string_select editor
    await createField(model, {
      label: "Category",
      api_key: "category",
      field_type: "string",
      appearance: {
        editor: "string_select",
        parameters: {
          options: [
            { label: "Technology", value: "technology" },
            { label: "Marketing", value: "marketing" }
          ]
        },
        addons: []
      },
      validators: {
        enum: {
          values: ["technology", "marketing"]
        }
      }
    });
    
    // 4. Text field with textarea editor
    await createField(model, {
      label: "Description",
      api_key: "description",
      field_type: "text",
      validators: {
        required: {},
        length: {
          min: 10,
          max: 500
        }
      }
    });
    
    // 5. Text field with wysiwyg editor
    await createField(model, {
      label: "Formatted Text",
      api_key: "formatted_text",
      field_type: "text",
      appearance: {
        editor: "wysiwyg",
        parameters: {},
        addons: []
      }
    });
    
    // 6. Text field with markdown editor
    await createField(model, {
      label: "Markdown Content",
      api_key: "markdown_content",
      field_type: "text",
      appearance: {
        editor: "markdown",
        parameters: {},
        addons: []
      }
    });
    
    // 7. Integer field
    await createField(model, {
      label: "Order Index",
      api_key: "order_index",
      field_type: "integer",
      validators: {
        required: {},
        number_range: {
          min: 1,
          max: 100
        }
      }
    });
    
    // 8. Float field
    await createField(model, {
      label: "Product Price",
      api_key: "product_price",
      field_type: "float",
      validators: {
        required: {},
        number_range: {
          min: 0.01,
          max: 9999.99
        }
      }
    });
    
    // 9. Boolean field
    await createField(model, {
      label: "Published",
      api_key: "published",
      field_type: "boolean"
    });
    
    // 10. Date field
    await createField(model, {
      label: "Publication Date",
      api_key: "publication_date",
      field_type: "date",
      validators: {
        required: {}
      }
    });
    
    // 11. Date time field
    await createField(model, {
      label: "Event Date Time",
      api_key: "event_date_time",
      field_type: "date_time",
      validators: {
        required: {}
      }
    });
    
    // 12. File field
    await createField(model, {
      label: "Featured Image",
      api_key: "featured_image",
      field_type: "file",
      validators: {
        required: {}
      }
    });
    
    // 13. Video field
    await createField(model, {
      label: "Featured Video",
      api_key: "featured_video",
      field_type: "video"
    });
    
    // 14. Link field (single reference)
    await createField(model, {
      label: "Primary Author",
      api_key: "primary_author",
      field_type: "link",
      appearance: {
        editor: "link_select",
        parameters: {},
        addons: []
      },
      validators: {
        item_item_type: {
          item_types: [refModel.id]
        }
      }
    });
    
    // 15. Links field (multiple references)
    await createField(model, {
      label: "Related Articles",
      api_key: "related_articles",
      field_type: "links",
      appearance: {
        editor: "links_select",
        parameters: {},
        addons: []
      },
      validators: {
        items_item_type: {
          item_types: [model.id]
        }
      }
    });
    
    // 16. Location field
    await createField(model, {
      label: "Event Location",
      api_key: "event_location",
      field_type: "lat_lon",
      validators: {
        required: {}
      }
    });
    
    // 17. Slug field
    await createField(model, {
      label: "Page Slug",
      api_key: "page_slug",
      field_type: "slug",
      validators: {
        required: {},
        slug_format: {
          predefined_pattern: "webpage_slug"
        }
      }
    });
    
    // 18. JSON field with json editor
    await createField(model, {
      label: "Custom Settings",
      api_key: "custom_settings",
      field_type: "json",
      validators: {
        required: {}
      }
    });
    
    // 19. JSON field with string_multi_select editor
    await createField(model, {
      label: "Tags",
      api_key: "tags",
      field_type: "json",
      appearance: {
        editor: "string_multi_select",
        parameters: {
          options: [
            { label: "Technology", value: "technology" },
            { label: "Design", value: "design" },
            { label: "Marketing", value: "marketing" }
          ]
        },
        addons: []
      }
    });
    
    // 20. JSON field with string_checkbox_group editor
    await createField(model, {
      label: "Features",
      api_key: "features",
      field_type: "json",
      appearance: {
        editor: "string_checkbox_group",
        parameters: {
          options: [
            { label: "Premium Support", value: "premium_support" },
            { label: "Fast Delivery", value: "fast_delivery" }
          ]
        },
        addons: []
      }
    });
    
    // 21. Single block field
    await createField(model, {
      label: "Hero Section",
      api_key: "hero_section",
      field_type: "single_block",
      validators: {
        single_block_blocks: {
          item_types: [textBlockModel.id, imageBlockModel.id]
        }
      }
    });
    
    // 22. SEO field
    await createField(model, {
      label: "SEO Metadata",
      api_key: "seo_metadata",
      field_type: "seo"
    });
    
    // 23. Structured text field
    await createField(model, {
      label: "Structured Content",
      api_key: "structured_content",
      field_type: "structured_text",
      validators: {
        structured_text_blocks: {
          item_types: [textBlockModel.id, imageBlockModel.id]
        },
        structured_text_links: {
          item_types: [model.id, refModel.id]
        }
      }
    });
    
    // 24. Rich text field
    await createField(model, {
      label: "Rich Text Content",
      api_key: "rich_text_content",
      field_type: "rich_text",
      validators: {
        rich_text_blocks: {
          item_types: [textBlockModel.id, imageBlockModel.id]
        }
      }
    });
    
    // 25. Gallery field
    try {
      await createField(model, {
        label: "Image Gallery",
        api_key: "image_gallery",
        field_type: "gallery",
        validators: {
          size: {
            min: 1
          }
        }
      });
    } catch (error) {
    }
    
    // 26. Color field
    try {
      await createField(model, {
        label: "Brand Color",
        api_key: "brand_color",
        field_type: "color"
      });
    } catch (error) {
    }
    
    return { model, refModel, textBlockModel, imageBlockModel };
  } catch (error) {
    throw error;
  }
}

// Execute the function
createComprehensiveModel()
  .then(() => {
    
    // Write results to file
    fs.writeFileSync('final_comprehensive_results.json', JSON.stringify(results, null, 2));
    
    // Create a markdown summary
    const fieldSummary = `# Final Comprehensive DatoCMS Field Types Results

## Successfully Created Fields (${results.successful.length})
${results.successful.map(field => `- ✅ ${field.field_type} (${field.editor}): ${field.label}`).join('\n')}

## Failed Fields (${results.failed.length})
${results.failed.map(field => `- ❌ ${field.field_type} (${field.editor}): ${field.label} - Error: ${field.error}`).join('\n')}

## Implementation Notes

This script demonstrates a comprehensive set of field types available in the DatoCMS Content Management API.

### Key Findings:
1. The API requires the 'addons' and 'parameters' properties on all appearance objects
2. Each field type has specific validator requirements
3. Field type configurations must follow strict schemas
4. Structured text and rich text fields need specific validators
5. Block models must have modular_block: true
6. Reference fields require appropriate validator configuration

### Field Types Successfully Implemented:
- Text fields (string, text) with various editors (single_line, textarea, wysiwyg, markdown)
- Selection fields (radio groups, select dropdowns)
- Numeric fields (integer, float)
- Date fields (date, date_time)
- Boolean fields
- Media fields (file, video)
- Reference fields (link, links)
- Advanced content fields (structured_text, rich_text, single_block)
- Special fields (slug, lat_lon, json, seo)
`;
    
    fs.writeFileSync('final_comprehensive_results.md', fieldSummary);
  })
